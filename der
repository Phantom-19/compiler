#!usr/bin/python2
# coding=utf-8 
# Faxel
"""
"\n# -*- coding: UTF-8 -*-
\n'''\033[1;94mFax-Cryptage {}
\n\033[1;95mDev \033[1;91m: Faxel \n'''
\nimport sys\nimport zlib as zn\nfrom base64 import *\nimport marshal as mc\n\ndef main_code():
\n    exec(mc.loads(zn.decompress(b16decode('{}'))))
\n\nmain_code()\n".format(time.ctime(), compresse)"""

import zlib as zn
from base64 import *
import marshal as mc
import zlib, base64, time, sys, os ,datetime, random
logo1 = ("""\033[1;96m       ╔═╗┬─┐┬ ┬┌─┐┌┬┐┌─┐┌─┐┌─┐ \n\033[1;96m       ║  ├┬┘└┬┘├─┘ │ ├─┤│ ┬├┤  \n\033[1;96m       ╚═╝┴└─ ┴ ┴   ┴ ┴ ┴└─┘└─┘ """)
logo = ("""\033[38;5;214m●▬▬▬▬▬▬▬▬๑\033[1;97m●▬▬▬▬▬▬๑۩۩๑▬▬▬▬▬▬●●▬▬▬▬▬\033[1;32m▬▬▬▬๑۩۩๑▬▬▬▬▬▬●     \n\033[38;5;214m•_  _ ____ \033[1;97m _  _ ____ ____ _  _\033[1;32m ____ ____   _  _• \n\033[38;5;214m•|\/| |__/ \033[1;97m |__| |__| |    |_/ \033[1;32m |___ |__/   |_/ • \n\033[38;5;214m•|  | |  \ \033[1;97m |  | |  | |___ | \_\033[1;32m |___ |  \ __| \_• \n\033[38;5;214m●▬▬▬▬▬▬▬▬๑\033[1;97m●▬▬▬▬▬▬๑۩۩๑▬▬▬▬▬▬●●▬▬▬▬▬\033[1;32m▬▬▬▬๑۩۩๑▬▬▬▬▬▬●\n\033[1;97m╔═════════════════════════════════════════════╗\n\033[1;97m║\033[1;91m[\033[1;93m**\033[1;91m]\033[38;5;95m      Developpeur \033[1;97m:\033[38;5;214m  Faxel           \033[1;91m[\033[1;93m**\033[1;91m]\033[1;97m║\n\033[1;97m╚═════════════════════════════════════════════╝
""")	
os.system("clear")
print(logo)
print(logo1) 

#try:
    #dmd = raw_input('\033[1;93mScript a crypter \033[1;91m: \033[1;97m')
    #reoriente = mc.dumps(compile(open(dmd, 'rb').read(), '<string>', 'exec'))
#except:
    #print ("\033[1;91mFichier introuvable ou invalide")
    #sys.exit()
#compresse = base64.b16encode(zlib.compress(reoriente))
#codeur1 = "\n# -*- coding: UTF-8 -*-\n'''\033[1;94mFax-Cryptage {}\n\033[1;95mDev \033[1;91m: Faxel \n'''\nimport sys\nimport zlib as zn\nfrom base64 import *\nimport marshal as mc\n\ndef main_code():\n    exec(mc.loads(zn.decompress(b16decode('{}'))))\n\nmain_code()\n".format(time.ctime(), compresse)

#codeur2 = '\nimport marshal , base64\nexec(marshal.loads(base64.b16decode("{}")))\n'.format(base64.b16encode(mc.dumps(compile(codeur1, '<string>', 'exec'))))
#codeur3 = '\nimport marshal , base64\nexec(marshal.loads(base64.b32decode("{}")))\n'.format(base64.b32encode(mc.dumps(compile(codeur2, '<string>', 'exec'))))

####################################################################################################
def decodeur():
	
	
	
                        le_mot = raw_input('\033[1;91m[\033[1;97m**\033[1;91m] \033[1;95mSaisissez votre texte\033[1;91m : \033[1;97m ')
                        if len(le_mot)%3 == 2:
	                        rembourrage = '='
                        elif len(le_mot)%3 == 1:
	                        rembourrage = '=='
                        else:
	                        rembourrage = ''
			print("")
		        print "\033[1;91m[\033[1;93m---\033[1;91m]\033[1;97m  Le texte coder est le suivant \033[91;1m:\n\n[38;5;70m {}".format(le_mot)
		        print("")
                        print "\033[1;91m[\033[1;93m***\033[1;91m][38;5;228m  Il est constituer de\033[1;93m",len(le_mot), '[38;5;228mcaracteres \033[1;91m[\033[1;93m***\033[1;91m]'             
		        print("")
		        ligne="\033[1;92m═"*25
		        print ""+ligne
                        print "\n\033[1;97mVoici les valeurs en \033[1;93mbinaires\033[1;97m et en \033[1;94mascii\033[1;97m pour chaque caractère saisi"
		        print("")
                        b = ''
                        for i in le_mot:
	                      print '\033[1;95m%s\033[1;97m, en\033[1;92m binaire \033[1;91m●═════► \033[1;95m%s\033[1;97m, en\033[1;94m ascii \033[1;91m●═════► \033[1;95m%s'%(i, bin(ord(i))[2:].zfill(8),ord(i))
	                      b += str(bin(ord(i))[2:].zfill(8)+ ' ')
		        print ""+ligne
                        print '\n\033[1;97mFichiers binaires repartie en caractere de votre saisie\033[1;92m"\033[1;92m%s\033[1;95m"\033[1;97m est\033[1;95m "\033[1;96m%s\033[1;96m"'%(le_mot,b[:-1])
		        print("")
                        print '\n\033[1;97mL\'alignement des fichiers binaires \033[1;91m(\033[1;94mc\'est a dire en binaire groupé\033[1;91m)\033[1;97m de votre saisie\033[1;95m"\033[1;92m%s\033[1;95m"\033[1;97m est \033[1;95m"\033[1;93m%s\033[1;95m"'%(le_mot,(b).replace(' ',''))
		        print("")
                        print "\n\033[1;97mLe Processus par\033[1;91m 6\033[1;93m bits\033[1;97m implique que tous les\033[1;91m 6\033[1;93m bits\033[1;97m representeront un caractere de base64\033[1;93m"
		        print("")
                        x = (b).replace(' ','')
                        print (x)
                        k = '-'.join(x[i:i+6] for i in range(0, len(x), 6))
                        print ('\n' + k)
                        if rembourrage != '':
	                     print '\n\033[1;97mSi la longueur du mot n\'est pas un multiple de\033[1;91m 3\033[1;97m,\nil y aura un remplissage de\033[1;95m "\033[1;92m%s\033[1;95m" tant que c\'est\033[1;96m %s caracteres '%(rembourrage,len(rembourrage))
	                     n = ',\033[1;94m avec rembourrage'
                        else:
	                     n = ''		
		        print ""+ligne
                        print '\n\033[1;93mBinaire  \033[1;91m = \033[1;94mDecimal\033[1;91m  =   \033[1;97m Caractere base\033[1;96m64\033[1;95m'
		        print("")
                        ant = ''
                        w = {0:'A',1:'B',2:'C',3:'D',4:'E',5:'F',6:'G',7:'H',8:'I',9:'J',10:'K',11:'L',12:'M',13:'N',14:'O',15:'P',16:'Q',17:'R',18:'S',19:'T',20:'U',21:'V',22:'W',23:'X',24:'Y',25:'Z',26:'a',27:'b',28:'c',29:'d',30:'e',31:'f',32:'g',33:'h',34:'i',35:'j',36:'k',37:'l',38:'m',39:'n',40:'o',41:'p',42:'q',43:'r',44:'s',45:'t',46:'u',47:'v',48:'w',49:'x',50:'y',51:'z',52:'0',53:'1',54:'2',55:'3',56:'4',57:'5',58:'6',59:'7',60:'8',61:'9',62:'+',63:'/'}
                        for c in k.split('-'):
	                        if len(c) == 6:
		                        mael = '00' + c
	                        elif len(c) == 4:
		                        mael = '00' + c + '00'
	                        elif len(c) == 2:
		                        mael = '00' + c + '0000'
	                        m = int(mael,2)
	                        if len(str(m)) == 1:
		                        m = str(m) + ' '
	                        j = ''.join(w[o] for o in w if int(m) == o)
	                        print '%s = %s      = %s'%(mael , m , j)
	                        ant += j
			regi1 = open(code1,"w")
		        regi1.write(coder1)
		        regi1.close()
		        print '\n\033[1;97mLe resultat de votre saisie pour l\'encodage Base64%s\033[1;97m est\033[1;91m :         \n\n %s\033[1;96m'%(n,ant+rembourrage)             		       
		        fichier.write('%s'+"\n")
                        toc = time.clock()
                        ttn = toc - tic
		        print ("[38;5;212m<═════════════════════════════════════════>\n")
		        print ("\x1b[1;97m║\033[1;91m[\033[1;97m--\033[1;91m] \x1b[1;97mEnregistrer sous [38;5;112m "+str(trap)+"\x1b[1;97m dans votre repertoire.\x1b[1;97m║")
                        print ("\x1b[1;97m║\033[1;91m[\033[1;97m**\033[1;91m] [38;5;108mTerminer en\x1b[1;92m "+str(ttn)+" [38;5;108msecondes.\x1b[1;97m║\n")
                        print ("[38;5;212m<═════════════════════════════════════════>\n")
		        print ("                       \033[48;5;0;38;5;197mMr Faxel                   ") 
			raw_input('\n\033[1;91m[\033[1;97mRetour\033[1;91m]')
		        #bases()
		#else:
			#bases()
####################################################################################################			
def shell_mars():
	
	
	        decodeur=raw_input("\033[1;91m[\033[1;93m***\033[1;91m][38;5;79m  Saisissez votre texte a decoder.    \033[1;91m[\033[1;93m***\033[1;91m]\n\n\033[1;97m")
		print("")
		tic = time.clock()
		print("")
                trap =raw_input("\033[1;91m[\033[1;97m++\033[1;91m] [38;5;218mNommez votre resultats\x1b[1;91m : \x1b[1;93m ") 
		fichier=file(trap,"w")
		print "\033[1;91m[\033[1;93m---\033[1;91m]\033[1;97m  Votre texte en Base64 a decoder est \033[91;1m:\n\n[38;5;70m {}".format(decodeur)
		print("")
                print "\033[1;91m[\033[1;93m***\033[1;91m][38;5;221m  Il est constituer de\033[1;93m",len(decodeur), '[38;5;221mcaracteres \033[1;91m[\033[1;93m***\033[1;91m]'
                print ("\x1b[1;97m║\033[1;91m[\033[1;97m**\033[1;91m] [38;5;108mTerminer en\x1b[1;92m "+str(ttn)+" [38;5;108msecondes.\x1b[1;97m║\n")
		systeme1 = decodeur.decode("UTF-8")
		faxel = systeme1.decode("UTF-8")
                mael = base64.b64decode(faxel)
                systeme2 = mael.decode("UTF-8")  
		save = open(trap,"w")
		save.write(systeme2)
		save.close()
		toc = time.clock()
                ttn = toc - tic
		raw_input('\n\033[1;91m[\033[1;97mRetour\033[1;91m]')
g= ("""		
	script_mars = raw_input("\033[1;97m╚═\033[1;31m▶\033[1;97m Entrer le nom du script a crypter \033[1;91m▶▶▶ \033[1;97m")
	try:
		ouverture = open(script_mars,'r').read()
	except IOError:
		print ("\033[1;91m [\033[1;93m!\033[1;91m]\033[1;97m Script introuvable")
		menu()
	print("\033[1;97m║")
	emplacement = raw_input("\033[1;97m╚═\033[1;31m▶\033[1;97m Nommer le resultat du cryptage \033[1;91m▶▶▶ \033[1;97m")
	code1 = raw_input("\033[1;97m╚═\033[1;31m▶\033[1;97m Nommer le resultat du cryptage \033[1;91m▶▶▶ \033[1;97m")
	code2 = raw_input("\033[1;97m╚═\033[1;31m▶\033[1;97m Nommer le resultat du cryptage \033[1;91m▶▶▶ \033[1;97m")
	#charge()
	try:
		coder1 = ""
                coder2 = ""
		i = 11
                for x in bytearray(script_mars) :
	                if i == 16:
		             i = 11
	                y = x^i
	                coder1 += '\\x'
	                coder1 += '%02x' % y
	                coder2 += '0x'
	                coder2 += '%02x,' %y	
	                i = i + 0x01
		enregistrement = open(emplacement,"w")
		enregistrement.write("#Compiler par Faxel\n#Twitter : https://twitter.com/Faxel2020\nimport marshal\nexec(marshal.loads("+repr(coder1)+"))")
		enregistrement.close()		
		regi1 = open(code1,"w")
		regi1.write(coder1)
		regi1.close()
		regi2= open(code2,"w")
		regi2.write(coder2)
		regi2.close()
		print ("\033[1;91m [\033[1;97m*\033[1;91m]\033[1;92m Compilage reussi")
		raw_input('\033[1;91m  [\033[1;97m!\033[1;91m]\033[1;97m Appuyer entrer pour retourner au menu\033[1;93m...')
		#menu()
	except:
		print ("\033[1;91m [\033[1;97m*\033[1;91m]\033[1;94m Compilage echouer")
		raw_input('\033[1;91m  [\033[1;97m!\033[1;91m]\033[1;97m Appuyer entrer pour retourner au menu\033[1;93m...')
                #menu() 

     Texte = raw_input('\033[1;97m╚═\033[1;31m▶ \033[1;95mSaisissez votre texte\033[1;91m \n\t\033[1;97m ') 	
     script_mars = raw_input("\033[1;97m╚═\033[1;31m▶\033[1;97m Entrer le nom du script a crypter \033[1;91m▶▶▶ \033[1;97m")
     emplacement = raw_input("\033[1;97m╚═\033[1;31m▶\033[1;97m Nommer le resultat du cryptage \033[1;91m▶▶▶ \033[1;97m")
     coder1 = ""
     coder2 = ""
     ouverture = open(script_mars, 'r').read()
     print ('Nombre de caractere de mot saisi: %d' % len(bytearray(Texte)))
     print ('Codage en Shell.......')
     time.sleep(2)
     i = 11
     for x in bytearray(script_mars) :
	     if  i == 16:
		  i = 11
	     y = x^i
	     coder1 += '\\x'
	     coder1 += '%02x' % y
	     coder2 += '0x'
	     coder2 += '%02x,' %y	
	     i = i + 0x01	
     
     print (coder1)
     print (coder2)
     print ('Nombre de caractere en shell avec la methode simple  : %d' % len(bytearray(coder1)))
     print ('Nombre de caractere en shell avec la methode complexe: %d' % len(bytearray(coder2)))
     raw_input('\033[1;91m  [\033[1;97m!!\033[1;91m]\033[1;97m Appuyer entrer pour retourner au menu\033[1;93m...')
	""")
	
("""##################################
        script_mars = raw_input("\033[1;97m╚═\033[1;31m▶\033[1;97m Entrer le nom du script a crypter \033[1;91m▶▶▶ \033[1;97m")
	try:
		ouverture = open(script_mars,'r').read()
	except IOError:
		print ("\033[1;91m [\033[1;93m!\033[1;91m]\033[1;97m Script introuvable")
		menu()
	print("\033[1;97m║")
	emplacement = raw_input("\033[1;97m╚═\033[1;31m▶\033[1;97m Nommer le resultat du cryptage \033[1;91m▶▶▶ \033[1;97m")
	charge()
	try:
		depot = ouverture.replace('\r\n', '\n')
	        depot = depot.replace('\r', 'n')
	        if depot and depot[(-1)] != '\n':
	            depot = depot + '\n'
	        compilage = pp.compile(depot, '<r>', 'exec')
	        vidage = marshal.dumps(compilage)
		enregistrement = open(emplacement,"w")
		enregistrement.write("#Compiler par Faxel\n#Twitter : https://twitter.com/Faxel2020\nimport marshal\nexec(marshal.loads("+repr(vidage)+"))")
		enregistrement.close()
		print ("\033[1;91m [\033[1;97m*\033[1;91m]\033[1;92m Compilage reussi")
		raw_input('\033[1;91m  [\033[1;97m!\033[1;91m]\033[1;97m Appuyer entrer pour retourner au menu\033[1;93m...')
		menu()
	except:
		print ("\033[1;91m [\033[1;97m*\033[1;91m]\033[1;94m Compilage echouer")
		raw_input('\033[1;91m  [\033[1;97m!\033[1;91m]\033[1;97m Appuyer entrer pour retourner au menu\033[1;93m...')
                menu() 

####################################################################################################
        script_mars = raw_input("\033[1;97m╚═\033[1;31m▶\033[1;97m Entrer le nom du script a crypter \033[1;91m▶▶▶ \033[1;97m")
	try:
		ouverture = open(script_mars, 'rb').read()
		#mc.dumps(compile(open(script_mars, 'rb').read(), '<string>', 'exec'))
	except IOError:
		print ("\033[1;91m [\033[1;93m!\033[1;91m]\033[1;97m Script introuvable")
		mars_zlib_base()
	print("\033[1;97m║")
	emplacement = raw_input("\033[1;97m╚═\033[1;31m▶\033[1;97m Nommer le resultat du cryptage \033[1;91m▶▶▶ \033[1;97m")
	charge()
	try:
		bac2k20 = base64.b16encode(zlib.compress(ouverture))
		compilage = mc.dumps(compile(bac2k20, '<string>', 'exec'))
	        vid_z = marshal.dumps(compilage)
		enregistrement = open(emplacement,"w")
		enregistrement.write("#Compiler par Faxel\n#Twitter : https://twitter.com/Faxel2020\nimport marshal , base64\nexec(marshal.loads(base64.b16decode('"+repr(vid_z)+"')))")
		enregistrement.close()
		print ("\033[1;91m [\033[1;97m*\033[1;91m]\033[1;92m Compilage reussi")
		raw_input('\033[1;91m  [\033[1;97m!!\033[1;91m]\033[1;97m Appuyer entrer pour retourner au menu\033[1;93m...')
		mars_zlib_base()
	except:
		print ("\033[1;91m [\033[1;97m*\033[1;91m]\033[1;94m Compilage echouer")
		raw_input('\033[1;91m  [\033[1;97m!!\033[1;91m]\033[1;97m Appuyer entrer pour retourner au menu\033[1;93m...')
                mars_zlib_base() 
		import marshal,zlib,base64
                exec(marshal.loads(zlib.decompress(base64.b32decode(""))))
""")		
if __name__ == "__main__":
	#dec_mars()
	shell_mars()
